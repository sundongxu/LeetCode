/* 
    时间复杂度要求为对数时间，即O(logn)
    题目意思是找n的阶乘 n! 末尾的0的个数
    比较容易想到的是找相乘为10的整数倍的数，如2*5，1*10就更不说了
    根据数论知识：任何正整数都可以表示为若干质因数的乘积
    故问题转换为计算质因数5和2的个数，取小的即可
    而根据阶乘的计算过程，显然质因数2的个数远远多于5的个数
    故问题再次转化为计算质因数5的个数，做法就是看看n是5的多少倍，取整！
    比如5，为5的1倍，故阶乘质因数分解后只含有1个5
    比如10，为5的2倍，故阶乘质因数分解后有2个5，10和5各贡献一个
    比如25，为5的5倍，而阶乘质因数分解后有6个5，5-10-15-20分别贡献1个
    而25=5*5，即25贡献5个5，要特别注意！！！
 */
// 法一：迭代
// 1.异常处理， 小于0的数返回-1.
// 2. 先计算5的正整数幂都有哪些， 不断使用 n / 5 即可知质因数5的个数。
// 3. 在循环时使用 n /= 5 而不是 i *= 5 , 可有效防止溢出
// 复杂度分析：
// 时间复杂度：关键在于 n /= 5 执行的次数，复杂度为log5n, 即以5为底，n的对数，
// 空间复杂度：使用了count作为返回值，空间复杂度为O(1)
class Solution
{
  public:
    int trailingZeroes(int n)
    {
        if (n < 0)
            return -1;
        int count = 0;
        for (; n > 0; n /= 5)
            count += (n / 5);
        return count;
    }
};

// 递归，能用迭代的往往用递归，而且更优雅
// 递归的关键在于何时结束递归，即递归的终止条件，也就是最简单的return情况
class Solution
{
  public:
    int trailingZeroes(int n)
    {
        if (n < 0)
            return -1;
        else if (n == 0)
            return 0;
        else
            return n / 5 + trailingZeroes(n / 5);
    }
};