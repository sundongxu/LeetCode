/*
    以1为根的树的个数，等于其左子树的个数乘以右子树的个数
    以2为根的树的个数，等于其左子树的个数乘以右子树的个数
    以此类推...

    当数组为1，2，3，...，n时，基于以下原则构建的BST树具有唯一性：
    以i为根结点的树，其左子树由[1,i-1]范围内的元素构成，右子树由[i+1,n]范围内的元素构成

    定义f(i)为以[1,i]能产生的Unique Binary Search Tree的数目，则
    如果数组为空，毫无疑问，只有一种BST，即空树，f(0)=1
    如果数组仅有一个元素1，只有一种BST，即该结点作为根结点的树，f(1)=1
    如果数组有两个元素1，2，那么有如下两种可能：
        1             2
          \    和    /
            2      1 
      即 f(2) = f(0) * f(1)  // 1为根的情况，其左子树有0个结点，右子树有1个结点
              + f(1) * f(0)  // 2为根的情况，其左子树有1个结点，右子树有0个结点

    再看看含有三个元素的数组，可以发现BST的取值方式如下：
         f(3) = f(0) * f(2)  // 1为根的情况，其左子树有0个结点，右子树有2个结点
                f(1) * f(1)  // 2为根的情况，其左子树有1个结点，右子树有1个结点
                f(2) * f(0)  // 3位根的情况，其左子树有2个结点，右子树有0个结点

    由此可得，f的递推公式为：f(i) = Sum(f(k-1)f(i-k))，k=1...i，Sum表示累加求和
    至此，问题化为一维动态规划问题

*/

class Solution
{
  public:
    int numTrees(int n)
    {
        vector<int> f(n + 1, 0);
        f[0] = 1;
        f[1] = 1;

        for (int i = 2; i <= n; i++)
            for (int k = 1; k <= i; k++)
                f[i] += f[k - 1] * f[i - k];
        return f[n];
    }
};